<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Switch view from 2D to 3D | Sample | ArcGIS Maps SDK for JavaScript 4.26</title>
<script src="https://cdn.jsdelivr.net/npm/jsqr/dist/jsQR.js"></script>
  <style>
    html,
    body,
    #viewDiv {
      padding: 0;
      margin: 0;
      height: 107%;
      width: 100%;
    }
    #overviewDiv {
    position: absolute;
    top: 50%;
    left: 20px;
    width: 300px;
    height: 200px;
    border: 1px solid black;
    z-index: 1;
    overflow: hidden;
    transform: translate(0, -50%);
}
    #infoDiv {
      position: absolute;
      top: 15px;
      left: 60px;
    }

    #infoDiv input {
      border: none;
      box-shadow: rgba(0, 0, 0, 0.3) 0px 1px 2px;
    }
    #optionsDiv {
      background-color: white;
      color: black;
      padding: 6px;
      max-width: 800px;
      }
      #extentDiv {
        background-color: rgba(0, 0, 0, 0.5);
        position: absolute;
        z-index: 2;
      }
      #info {
        padding: 5px;
        margin: 5px;
        width: 120px;
        text-align: center;
      }
      esri-elevation-profile.esri-component.esri-widget--panel {
     
        width: 400px !important;
      }
  </style>

  <link rel="stylesheet" href="https://jsdev.arcgis.com/4.27/esri/themes/light/main.css" />
  <script src="https://jsdev.arcgis.com/4.27/"></script>
  <script>
     require([
    
        "esri/Map",
        
        "esri/Basemap",
        "esri/layers/SceneLayer",
        "esri/widgets/BasemapToggle",
        "esri/widgets/LayerList",
        "esri/WebMap",
        "esri/WebScene",
         "esri/views/SceneView",
         "esri/widgets/BasemapGallery",
         "esri/views/MapView",
         "esri/widgets/Editor",
          "esri/Graphic", 
          "esri/core/reactiveUtils",
           "esri/core/promiseUtils", 
           "esri/widgets/ElevationProfile",
            "esri/widgets/Locate",
            "esri/widgets/Legend",
            "esri/widgets/Search",
            "esri/layers/FeatureLayer",
       
            "esri/layers/GraphicsLayer",
            "esri/geometry/Polyline",
            "esri/geometry/geometryEngine"
       
            ],function (
             
        Map,
       
        Basemap,
        SceneLayer,
        BasemapToggle,
        LayerList,
        WebMap,
      WebScene,
        SceneView,
     BasemapGallery,
        MapView,
        Editor,
        Graphic,
        reactiveUtils,
        promiseUtils,
        ElevationProfile, 
        Locate,
        Legend,
        Search,
        FeatureLayer,
         GraphicsLayer,
          Polyline,
        geometryEngine
      )  {
        
      const switchButton = document.getElementById("switch-btn");
//定义一个appConfig切换到2D与3D时执行不同的功能
      const appConfig = {
        mapView: null,
        sceneView: null,
        activeView: null,
        container: "viewDiv" // use same container for views
      };
      featureLayer = new FeatureLayer({
        portalItem: {
          id: "f992e4e151a94e26a1bb05297d0e2c62"
        },
      });
//在切换2D与3D部分的时候进行初始化
      const initialViewParams = {
        zoom: 12,
        center: [19,120],
        container: appConfig.container
      };
       //---1万纽约建筑---
       const sceneLayer = new SceneLayer({
          portalItem: {
            id: "2e0761b9a4274b8db52c4bf34356911e"
          },
          popupEnabled: false
        });
        

        // Create MeshSymbol3D for symbolizing SceneLayer
        const symbol = {
          type: "mesh-3d", // autocasts as new MeshSymbol3D()
          symbolLayers: [
            {
              type: "fill", // autocasts as new FillSymbol3DLayer()
              // If the value of material is not assigned, the default color will be grey
              material: {
                color: [244, 247, 134]
              }
            }
          ]
        };
        // Add the renderer to sceneLayer
        sceneLayer.renderer = {
          type: "simple", // autocasts as new SimpleRenderer()
          symbol: symbol
        };
        //url的地址为自己发布的地图，把url改成自己的地图就好了，其他不用修改。
      let layer = new FeatureLayer
        ({
          url: "	http://localhost:6080/arcgis/rest/services/globe_1/MapServer"
        });
        let layer1 = new FeatureLayer
        ({
          url: "http://localhost:6080/arcgis/rest/services/globe_1/MapServer"
        });
        //3d的基础地图
      const mainMap = new Map({
        basemap: "hybrid",

        ground: "world-elevation",
       
        layers:[sceneLayer],
        
      });
mainMap.add(layer1);
      // 鹰眼的地图 
      const overviewMap1 = new Map({
        basemap: "topo-vector",
        
      });
      //网络地图，用于切换地图
      const webscene = new WebScene({
          portalItem: {
            id: "a3bd04ebe7fe49fbae145ae6b9c66da7"
          }
        });
        //2D 的基础地图
      const overviewMap = new WebMap({
          portalItem: {
            id: "3e7a6c881f9b4e9baa4294512ac4da03"
          }
        });
      /*const overviewMap = new Map({ 
        layers: [layer]
      });*/
     
      // create 2D view and and set active
      appConfig.mapView = new MapView({
          container: "viewDiv",
          map: overviewMap,
          popup: {
            autoOpenEnabled: false,
            dockEnabled: true,
            dockOptions: {
              // dock popup at bottom-right side of view
              buttonEnabled: false,
              breakpoint: false,
              position: "bottom-right"
            }
          }
        });
      appConfig.mapView.map = overviewMap;
      appConfig.activeView = appConfig.mapView;
     
      // create 3D view, won't initialize until container is set
      initialViewParams.container = null;
      initialViewParams.map = mainMap;
      appConfig.sceneView = createView(initialViewParams, "3d");
   //--缓冲区部分--------------------------------------------------------------------------------------------------------
    // Add two graphics layers to map: one for points, another for buffers

    const bufferLayer = new GraphicsLayer();
        const pointLayer = new GraphicsLayer();
       // mainMap.addMany([bufferLayer, pointLayer]);
        overviewMap.addMany([bufferLayer, pointLayer]);
        
        

       

        const polySym = {
          type: "simple-fill", // autocasts as new SimpleFillSymbol()
          color: [140, 140, 222, 0.5],
          outline: {
            color: [0, 0, 0, 0.5],
            width: 2
          }
        };

        const pointSym = {
          type: "simple-marker", // autocasts as new SimpleMarkerSymbol()
          color: [255, 0, 0],
          outline: {
            color: [255, 255, 255],
            width: 1
          },
          size: 7
        };

        // Indicates whether buffering is enabled

        let bufferEnabled = false;

        /**
         * When the b key is tapped, then buffering is enabled.
         * @param {Object} event - The event object associated with the
         *   key-down event.
         */
        function keyDownListener(event) {
          const keyInput = event.key;
          bufferEnabled = (keyInput === "b") && !bufferEnabled;
          document.getElementById("mode").innerHTML = bufferEnabled ? "navigation" : "buffering";
        }

         appConfig.mapView.on("key-down", keyDownListener);
    //   appConfig.sceneView.on("key-down", keyDownListener);

         appConfig.mapView.on(["click", "pointer-move"], event => {
          if (bufferEnabled) {
            createBuffer(event,  appConfig.mapView);
          }
        });
        

              /**
         * Stops propagation on the given event and constructs a point for
         * buffering.
         *
         * @param {Object}   event - Event object containing XY screen coordinates.
         * @param {Mapview} view - View instance from which the point was obtained.
         */
        function createBuffer(event, view) {
          // prevent further propagation of the current event bubbling up the event chain.
          // in this case, it will prevent default `drag` event behavior for the MapView
          // which is to move around the view by dragging the pointer.
          event.stopPropagation();

          // convert screen coordinates to map coordinates
          const point = view.toMap(event);

          if (point) {
            bufferPoint(point);
          }
        }

        /**
         * Buffers the given point by 560 kilometers.
         *
         * @param {esri/geometry/Point} point - A point instance to buffer.
         */
        function bufferPoint(point) {
          if (!bufferEnabled) {
            console.log("buffering not enabled. Hit the b key and click/drag to buffer.");
            return;
          }

          // removes z-values from the point when taken from a SceneView.
          // GeometryEngine does not support 3D geometries.
          point.hasZ = false;
          point.z = undefined;

          if(pointLayer.graphics.length === 0){
            pointLayer.add(
              new Graphic({
                geometry: point,
                symbol: pointSym
              })
            );
          } else {
            const graphic = pointLayer.graphics.getItemAt(0);
            graphic.geometry = point;
          }

          /********************************************************************
            测地线缓冲区计算缓冲点的真实距离，
            最小化缓冲点时存在的失真
            从投影的相切线。这种扭曲是显而易见的
            在此应用程序的 2D 视图中。此地图使用 Web 墨卡托
           空间参考，在赤道处有一条相切线。
            在赤道上创建的缓冲区在其失真中几乎没有失真
            形状。在远离赤道的地方创建进一步的缓冲区，
           它们将更加扭曲，它们将处于它们的形状中。
           如果使用标准平面缓冲区，则缓冲区的形状不会
           在 2D 视图中失真，但它们的大小和面积会非常失真
           当他们远离赤道时。
           ********************************************************************/

          const buffer = geometryEngine.geodesicBuffer(point, 560, "kilometers");

          if(bufferLayer.graphics.length === 0){
            bufferLayer.add(
              new Graphic({
                geometry: buffer,
                symbol: polySym
              })
            );
          } else {
            const graphic = bufferLayer.graphics.getItemAt(0);
            graphic.geometry = buffer;
          }
        }
//------------------------------以下代码是2D视图中的代码------

var map = new Map({
    basemap: "topo-vector" // 或选择其他底图
  });

  var view = new MapView({
    container: "viewDiv", // 确保HTML中有一个id为viewDiv的元素
    map: overviewMap,
    center: [104.5, 45], // 设置视图的中心点
    zoom: 4 // 设置初始缩放级别
  });
  var graphicsLayer = new GraphicsLayer();
  map.add(graphicsLayer); // 确保已添加图层到地图

var points = [
    [99, 40], // 起点
    [110, 45], // 中间点
    [115, 50]  // 终点
  ];
  var polyline = new Polyline({
    paths: [points]
  });
  
  appConfig.mapView = new MapView({
    container: "viewDiv", // 指向HTML容器的ID
    map: overviewMap, // 使用上面创建的地图
    zoom: 4, // 设置初始缩放级别
    center: [15, 65] // 设置初始中心点（经度，纬度）
  });

/*function xyz(xx) {
  var query = layer.createQuery();
query.where = "INDEX_NO = "+xx; // 只查询INDEX_NO为61090的项
query.outFields = ["INDEX_NO", "LATITUDE", "LONGITUDE"]; // 只返回INDEX_NO, LATITUDE, LONGITUDE字段
query.orderByFields = []; // 不需要排序
query.num = 1; // 只需要返回一项

// 执行查询
layer.queryFeatures(query).then(function(results){
  if (results.features.length > 0) {
    var latitude = results.features[0].attributes.LATITUDE;
    var longitude = results.features[0].attributes.LONGITUDE;
    console.log("Latitude:", latitude, "Longitude:", longitude);
    return { latitude, longitude };
  } else {
    console.log("未找到INDEX_NO为61090的项");
    return null;
  }
}).catch(function(error){
  console.error("查询过程中发生错误：", error);
  return null;
});
  }

xyz(61090);
async function printAllFeaturesInfo(featureLayer) {
  // 创建一个查询对象
  var query = featureLayer.createQuery();
  query.where = "1=1"; // 这个条件表示选取所有要素
  query.outFields = ["*"]; // "*" 表示返回所有字段

  try {
    // 执行查询
    const results = await featureLayer.queryFeatures(query);
    // 获取要素数组
    const features = results.features;
    // 遍历所有要素
    features.forEach((feature, index) => {
      console.log(`要素 ${index + 1}:`);
      // 遍历并打印每个要素的属性
      for (let propName in feature.attributes) {
        console.log(`属性名: ${propName}, 属性值: ${feature.attributes[propName]}`);
      }
    });
  } catch (error) {
    console.error("查询过程中发生错误：", error);
  }
}

// 假设 featureLayer 已经定义
printAllFeaturesInfo(featureLayer);*/

  async function queryLatLonByIndex(indexNo) {
    var query = featureLayer.createQuery();
    query.where ="INDEX_NO = " + indexNo; // 使用模板字符串嵌入变量indexNo
    query.outFields = ["INDEX_NO", "LATITUDE", "LONGITUDE"]; // 只返回INDEX_NO, LATITUDE, LONGITUDE字段
    query.orderByFields = []; // 不需要排序
    query.num = 1; // 只需要返回一项
    
    try {
        // 使用await等待异步操作完成
        const results = await featureLayer.queryFeatures(query);
        if (results.features.length > 0) {
            var latitude = results.features[0].attributes.LATITUDE;
            var longitude = results.features[0].attributes.LONGITUDE;
            console.log("Latitude:", latitude, "Longitude:", longitude);
            return { latitude, longitude };
        } else {
            console.log("未找到INDEX_NO为61090的项");
            return null;
        }
    } catch (error) {
        console.error("查询过程中发生错误：", error);
        return null;
    }
}



window.drawPolyline = async function(codedata) {
  console.log("drawPolyline called"); // 确认函数被调用
  const input = codedata; // 获取用户输入
  console.log("User input:", input); // 打印用户输入

  // 解析输入点
  const points = input.split("\n").map(async (line) => {
// 解析经度
const lonDirection1 = line[0] === '0' ? 1 : -1; // 0为东经(正), 1为西经(负)
const longitudeDegrees1 = parseInt(line.substring(1, 4), 10);
const longitudeMinutes1 = parseInt(line.substring(4, 6), 10);
const longitudeSeconds1 = parseInt(line.substring(6, 8), 10);
const longitude1 = lonDirection1 * (longitudeDegrees1 + longitudeMinutes1 / 60 + longitudeSeconds1 / 3600);

// 解析纬度
const latDirection1 = line[8] === '0' ? 1 : -1; // 0为北纬(正), 1为南纬(负)
const latitudeDegrees1 = parseInt(line.substring(9, 11), 10);
const latitudeMinutes1 = parseInt(line.substring(11, 13), 10);
const latitudeSeconds1 = parseInt(line.substring(13, 15), 10);
const latitude1 = latDirection1 * (latitudeDegrees1 + latitudeMinutes1 / 60 + latitudeSeconds1 / 3600);

const lonDirection2 = line[25] === '0' ? 1 : -1; // 0为东经(正), 1为西经(负)
const longitudeDegrees2 = parseInt(line.substring(26, 29), 10);
const longitudeMinutes2 = parseInt(line.substring(29, 31), 10);
const longitudeSeconds2 = parseInt(line.substring(31, 33), 10);
const longitude2 = lonDirection2 * (longitudeDegrees2 + longitudeMinutes2 / 60 + longitudeSeconds2 / 3600);
  
const latDirection2 = line[33] === '0' ? 1 : -1; // 0为北纬(正), 1为南纬(负)
const latitudeDegrees2 = parseInt(line.substring(34, 36), 10);
const latitudeMinutes2 = parseInt(line.substring(36, 38), 10);
const latitudeSeconds2 = parseInt(line.substring(38, 40), 10);
const latitude2 = latDirection2 * (latitudeDegrees2 + latitudeMinutes2 / 60 + latitudeSeconds2 / 3600);

    // 后10位解析INDEX_NO
    const indexNo1 = line.substring(15, 20);
    console.log("latLon1:", indexNo1); // 打印第一组经纬度
    // 使用INDEX_NO查询经纬度
    const latLon1 = await queryLatLonByIndex(indexNo1);

    const indexNo2 = line.substring(20, 25);
    console.log("latLon2:", indexNo2); // 打印第二组经纬度

    const latLon2 = await queryLatLonByIndex(indexNo2);
    


   
    return [
      [longitude1, latitude1], // 第一组经纬度
     
      [latLon1.longitude, latLon1.latitude], // 第二组经纬度
      [latLon2.longitude, latLon2.latitude],// 第三组经纬度
      [longitude2, latitude2] // 第四组经纬度
     
    ];
  });

  // 等待所有点的查询完成
  const resolvedPoints = await Promise.all(points);
  console.log("Parsed points:", resolvedPoints); // 打印解析后的坐标点

 

  resolvedPoints.forEach(pointSet => {
    const polyline = new Polyline({
      paths: [pointSet]
    });
    const polylineGraphic = new Graphic({
      geometry: polyline,
      symbol: {
        type: "simple-line",
        color: [226, 119, 40], // 橙色
        width: 4
      }
    });

    appConfig.mapView.graphics.add(polylineGraphic);
  });

  console.log("Polyline graphics added to map"); // 确认图形已添加到地图
};

// JavaScript部分


  // 创建轨迹的图形表示
  var polylineGraphic = new Graphic({
    geometry: polyline,
    symbol: {
      type: "simple-line", // autocasts as SimpleLineSymbol
      color: [226, 119, 40], // 橙色
      width: 4
    }
  });

  // 将图形添加到图层 
  view.graphics.add(polylineGraphic);
        //2D搜索
      const searchWidget1 = new Search({
            view: appConfig.mapView
          });
        appConfig.mapView.ui.add(searchWidget1, "top-left");
       
        appConfig.mapView.ui.add("optionsDiv", "top-right");
        //2d图列
        const legend = new Legend({
          view: appConfig.mapView,
          layerInfos: [
            {
              layer: layer
            }
          ]
        });
        appConfig.mapView.when(() => {
          const editor = new Editor({
            view: appConfig.mapView
          });

          // Add the widget to the view
          appConfig.mapView.ui.add(editor, "top-right");
        });
        appConfig.mapView.ui.add(legend, "bottom-left");
        // additional query fields initially set to null for basic query
        let distance = null;
        let units = null;

        //create graphic for mouse point click
        const pointGraphic = new Graphic({
          symbol: {
            type: "simple-marker", // autocasts as new SimpleMarkerSymbol()
            color: [0, 0, 139],
            outline: {
              color: [255, 255, 255],
              width: 1.5
            }
          }
        });

        // Create graphic for distance buffer
        const bufferGraphic = new Graphic({
          symbol: {
            type: "simple-fill", // autocasts as new SimpleFillSymbol()
            color: [173, 216, 230, 0.2],
            outline: {
              // autocasts as new SimpleLineSymbol()
              color: [255, 255, 255],
              width: 1
            }
          }
        });

        // when query type changes, set appropriate values
        const queryOpts = document.getElementById("query-type");

        queryOpts.addEventListener("change", () => {
          switch (queryOpts.value) {
            // values set for distance query
            case "distance":
              distance = 0.5;
              units = "miles";
              break;
            default:
              // Default set to basic query
              distance = null;
              units = null;
          }
        });
        //2d部件修改-------------------------------------------------------
        layer.load().then(() => {
          // Set the view extent to the data extent
          appConfig.mapView.extent = layer.fullExtent;
          layer.popupTemplate = layer.createPopupTemplate();
        });

        appConfig.mapView.on("click", (event) => {
          appConfig.mapView.graphics.remove(pointGraphic);
          if (appConfig.mapView.graphics.includes(bufferGraphic)) {
            appConfig.mapView.graphics.remove(bufferGraphic);
          }
          queryFeatures(event);
        });

        function queryFeatures(screenPoint) {
          const point = appConfig.mapView.toMap(screenPoint);
          layer
            .queryFeatures({
              geometry: point,
              // distance and units will be null if basic query selected
              distance: distance,
              units: units,
              spatialRelationship: "intersects",
              returnGeometry: false,
              returnQueryGeometry: true,
              outFields: ["*"]
            })
            .then((featureSet) => {
              // set graphic location to mouse pointer and add to mapview
              pointGraphic.geometry = point;
              appConfig.mapView.graphics.add(pointGraphic);
              // open popup of query result
              appConfig.mapView.popup.open({
                location: point,
                features: featureSet.features,
                featureMenuOpen: true
              });
              if (featureSet.queryGeometry) {
                bufferGraphic.geometry = featureSet.queryGeometry;
                appConfig.mapView.graphics.add(bufferGraphic);
              }
            });
        }

//---------------------以下代码是3D视图中的代码------------------------------------------------------
          const mapView = new MapView({
          container: "overviewDiv",
          map:overviewMap1 ,
          constraints: {
            rotationEnabled: false
          }
        });
  
        
        appConfig.sceneView.when(() => {
          const toggle = new BasemapToggle({
            visibleElements: {
              title: true
            },
            view: appConfig.sceneView,
            nextBasemap: webscene
          });

          // Add widget to the top right corner of the view
          appConfig.sceneView.ui.add(toggle, "top-left");
          const layerList = new LayerList({
            view: appConfig.sceneView
          });

          // Add widget to the top right corner of the view
          appConfig.sceneView.ui.add(layerList, "bottom-left");
        });
        
       
//高程剖析
const elevationProfile = new ElevationProfile({
          view: appConfig.sceneView,
          // configure widget with desired profile lines
          profiles: [
            {
              type: "ground" // first profile line samples the ground elevation
            },
            {
              type: "view" // second profile samples the view and shows building profiles
            }
          ],
         
          visibleElements: {
            selectButton: false
          }
        });
          //3d图例
      
        appConfig.sceneView.ui.add(elevationProfile, "top-right");
        //定位
        const locateBtn = new Locate({
          view: appConfig.sceneView
        });
        appConfig.sceneView.ui.add(locateBtn, "bottom-left");
        
        // Remove the default widgets
            
        // add the widget to the view
        
        
       
         mapView.ui.components = [];

         mapView.when(() => {
          appConfig.sceneView.when(() => {
            setup();
          });
        });

        const extentDebouncer = promiseUtils.debounce(async () => {
          if (appConfig.sceneView.stationary) {
            await  mapView.goTo({
              center: appConfig.sceneView.center,
              scale:
                appConfig.sceneView.scale *
                2 *
                Math.max(
                  appConfig.sceneView.width /  mapView.width,
                  appConfig.sceneView.height /  mapView.height
                )
            });
          }
        });

        function setup() {
          const extent3Dgraphic = new Graphic({
            geometry: null,
            symbol: {
              type: "simple-fill",
              color: [0, 0, 0, 0.5],
              outline: null
            }
          });
           mapView.graphics.add(extent3Dgraphic);

          reactiveUtils.watch(
            () => appConfig.sceneView.extent,
            (extent) => {
              // Sync the overview map location
              // whenever the 3d view is stationary
              extentDebouncer().then(() => {
                extent3Dgraphic.geometry = extent;
              });
            },
            {
              initial: true
            }
          );
        }
       //-----以下代码是3d部件修改-------------
       const recreationLayer = new FeatureLayer({
          title: "Recreation",
          url: "https://services.arcgis.com/V6ZHFr6zdgNZuVG0/arcgis/rest/services/EditableFeatures3D/FeatureServer/1",
          elevationInfo: {
            mode: "absolute-height"
          },
          renderer: {
            type: "unique-value", // autocasts as new UniqueValueRenderer()
            field: "TYPE",
            visualVariables: [
              {
                // size can be modified with the interactive handle
                type: "size",
                field: "SIZE",
                axis: "height",
                valueUnit: "meters"
              },
              {
                // rotation can be modified with the interactive handle
                type: "rotation",
                field: "ROTATION"
              }
            ],
            uniqueValueInfos: [
              {
                value: "1",
                label: "Slide",
                symbol: {
                  type: "point-3d", // autocasts as new PointSymbol3D()
                  symbolLayers: [
                    {
                      type: "object",
                      resource: {
                        href: "https://static.arcgis.com/arcgis/styleItems/Recreation/gltf/resource/Slide.glb"
                      }
                    }
                  ],
                  styleOrigin: {
                    styleName: "EsriRecreationStyle",
                    name: "Slide"
                  }
                }
              },
              {
                value: "2",
                label: "Swing",
                symbol: {
                  type: "point-3d", // autocasts as new PointSymbol3D()
                  symbolLayers: [
                    {
                      type: "object",
                      resource: {
                        href: "https://static.arcgis.com/arcgis/styleItems/Recreation/gltf/resource/Swing.glb"
                      }
                    }
                  ],
                  styleOrigin: {
                    styleName: "EsriRecreationStyle",
                    name: "Swing"
                  }
                }
              }
            ]
          }
        });

        mainMap.add(recreationLayer);

        

        appConfig.sceneView.when(() => {
          appConfig.sceneView.popupEnabled = false; //disable popups
          // Create the Editor
          const editor1 = new Editor({
            view: appConfig.sceneView
          });
          // Add widget to top-right of the view
          appConfig.sceneView.ui.add(editor1, "bottom-right");
        });
        
      // switch the view between 2D and 3D each time the button is clicked
      switchButton.addEventListener("click", () => {
        switchView();
      });
      
      //2D与3D转换功能
      function switchView() {
        const is3D = appConfig.activeView.type === "3d";
        const activeViewpoint = appConfig.activeView.viewpoint.clone();

        // remove the reference to the container for the previous view
        appConfig.activeView.container = null;

        if (is3D) {
          // if the input view is a SceneView, set the viewpoint on the
          // mapView instance. Set the container on the mapView and flag
          // it as the active view

          appConfig.mapView.viewpoint = activeViewpoint;
          appConfig.mapView.container = appConfig.container;
          appConfig.activeView = appConfig.mapView;
          switchButton.value = "3D";
        
       

        } else {
          appConfig.sceneView.viewpoint = activeViewpoint;
          appConfig.sceneView.container = appConfig.container;
          appConfig.activeView = appConfig.sceneView;
          switchButton.value = "2D";
          
          

        }
      }

      // convenience function for creating either a 2D or 3D view dependant on the type parameter
      function createView(params, type) {
        let view;
        if (type === "2d") {
          view = new MapView(params);
          return view;
        } else {
          view = new SceneView(params);
        }
        return view;
      }
    });
  </script>

</head>

<body>
  <div id="viewDiv"></div>
  <!-- 将新的UI组件放在这里 -->
  <div id="inputDiv" style="position: absolute; top: 250px; right: 10px; z-index: 2;">
    <h3>输入点的坐标</h3>
    <!--<textarea id="pointsInput" rows="5" cols="20" placeholder="例如：\n99,40\n110,45\n115,50"></textarea>
    <button onclick="drawPolyline()">绘制溯源线</button>-->
    <input type="file" id="qr-input" accept="image/*"><script>
      // 你的JavaScript代码
      document.addEventListener('DOMContentLoaded', function() {
          document.getElementById('qr-input').addEventListener('change', function() {
              const file = this.files[0];
              if (!file) {
                  alert('请先选择一个文件！');
                  return;
              }
              const reader = new FileReader();
              reader.onload = function() {
                  const img = new Image();
                  img.onload = function() {
                      const canvas = document.createElement('canvas');
                      const context = canvas.getContext('2d');
                      canvas.width = img.width;
                      canvas.height = img.height;
                      context.drawImage(img, 0, 0, img.width, img.height);
                      const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
                      const code = jsQR(imageData.data, imageData.width, imageData.height, {
                          inversionAttempts: "dontInvert",
                      });
                      if (code) {
                          console.log('二维码解码成功：', code.data);
                          drawPolyline(code.data); // 确保你有定义drawPolyline函数或者根据需要修改这部分
                      } else {
                          alert('无法从图片中解码二维码，请确保图片中包含有效的二维码。');
                      }
                  };
                  img.onerror = function() {
                      alert('无法加载图片，请确保文件是一个有效的图片格式。');
                  };
                  img.src = reader.result;
              };
              reader.onerror = function() {
                  alert('读取文件时发生错误，请重试或选择其他文件。');
              };
              reader.readAsDataURL(file);
          });
      });
  </script>
    <button onclick="document.getElementById('qr-input').click()">选择并解码二维码</button>
    
  </div>
  <div id="overviewDiv"><div id="extentDiv"></div></div>
  <div id="infoDiv">
    <input class="esri-component esri-widget--button esri-widget esri-interactive" type="button" id="switch-btn"
      value="3D" />
      <div id="optionsDiv" class="esri-widget">
        <div id="info" class="esri-widget">
          <label class="chkLabel"
            >请 <strong>按b键</strong> 使用 <strong> <span id="mode">缓冲区查询</span>.</strong> 然后按空格键.
          </label>
        <p>
          选择一个查询方式
        </p>
        <select id="query-type" class="esri-widget">
          <option value="basic">基本查询</option>
          <option value="distance">按距离查询</option>
        </select>
  </div>

</body>

</html>